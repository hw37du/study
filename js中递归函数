当我们调用一个函数时，执行上下文被放置在执行栈上。
让我们进一步分解一下。
首先，什么是栈？
栈是一种基于“后进先出”操作的数据结构。
将item“push”到栈上以添加到其中，然后将item“pop”到栈上以将其删除。

现在，回到执行上下文是什么？执行上下文是在函数调用时形成的。此上下文将自身放在执行堆栈上，即操作顺序。
始终在此堆栈中排在最前面的项是全局执行上下文。接下来是任何函数创建的上下文。
这些执行上下文具有属性，激活对象和“ this”绑定。“ this”绑定是对该执行上下文的引用。激活对象包括：传递的参数，声明的变量和函数声明
因此，每次我们在堆栈上放置新的上下文时，通常我们便拥有执行代码所需的一切，为什么说通常呢？这里有一个特例，就是递归函数。
通过递归，我们正在等待来自其他执行上下文的返回值。
这些其他上下文在堆栈中更高。
当堆栈中的最后一项完成执行时，该上下文将生成一个返回值。
该返回值作为递归情况下的递归值传递到下一个项目。
然后将执行上下文弹出堆栈
通常，递归函数至少包含两部分：基本条件和至少一个递归情况

举个例子，阶乘函数
const factorial = function(num) {  debugger;  if (num === 0 || num === 1) {    return 1  } else {    return num * factorial(num - 1)  }}

我们可以看到如果将调试器语句插入代码并使用devtools逐步执行并观察调用堆栈，将会发生什么情况。
1，执行栈将factorial(5)push到栈中，方法执行的时候，if条件为false，所以进入到递归
2，执行栈将factorial(4)push到栈中，方法执行的时候，if条件为false，所以进入到递归
3，执行栈将factorial(3)push到栈中，方法执行的时候，if条件为false，所以进入到递归
4，执行栈将factorial(2)push到栈中，方法执行的时候，if条件为false，所以进入到递归
5，执行栈将factorial(1)push到栈中，方法执行的时候，if条件为true，所以返回1



参考文章
https://www.freecodecamp.org/news/recursion-is-not-hard-858a48830d83/
